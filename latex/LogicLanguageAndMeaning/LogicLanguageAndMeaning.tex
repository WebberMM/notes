% Created 2020-10-06 äºŒ 19:31
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\input{../preamble.tex}
\DeclareMathOperator{\VAR}{VAR}
\DeclareMathOperator{\CON}{CON}
\DeclareMathOperator{\WE}{WE}
\author{L. T. E. Gamut}
\date{\today}
\title{Logic Language And Meaning}
\hypersetup{
 pdfauthor={L. T. E. Gamut},
 pdftitle={Logic Language And Meaning},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents \clearpage\section{The Theory of Types and Categorical Grammar}
\label{sec:org9797873}

\subsection{The Theory of Types}
\label{sec:org57fa18c}
\subsubsection{Type Distinctions in Natural Language}
\label{sec:org44304eb}
\begin{enumerate}
\item If John is self-satisfied, then there is at least one thing he has in
common with Peter
\end{enumerate}


Sentence (1) contains quantification over properties.

\begin{enumerate}
\setcounter{enumi}{1}
\item Santa Claus has all the attributes of a sadist
\end{enumerate}


If we are to quantify not only over entities but also over properties of
entities, then we need to extend predicate logic by introducing variables
other than the ones we already have, which only range over entities. Besides
predicate letters, we need \textbf{predicate variables}, so that we can quantify over
this kind of variable in the syntax. Letting \(X\) be such a variable, (1)
and (2) may be represented as in (3) and (4):
\begin{enumerate}
\setcounter{enumi}{2}
\item \(Zj\to\exists X(Xj\wedge Xp)\)
\item \(\forall X(\forall x(Sx\to Xx)\to Xs)\)
\end{enumerate}


But second-order predicate logic does not exhaust the expressive power of
natural language. For not only are there natural language sentences which
quantify over properties of entities, but there are also sentences which
attribute properties to these properties of entities in turn.The predicate
\textbf{red} expresses a property of individuals, so the predicate \textbf{color} expresses a
property of properties of individuals. So in a sentence like \textbf{Red is a color},
which we represent as \(\calc(R)\), the second-order predicate \textbf{color} is
applied to the first-order predicate \textbf{red}. We can also quantify over these
properties of properties, as in \textbf{Red has something in common with green}.

Besides higher-order predicates, there are other kinds of expressions which
for linguistic purposes may usefully be added to predicate logic.

Our first class of examples is formed by expressions with \textbf{predicate
adverbials}
\begin{enumerate}
\setcounter{enumi}{4}
\item John is walking quickly
\end{enumerate}


The expression \textbf{quickly} is, form a linguistic perspective, a modifier acting
on the verb \textbf{is walking}. From a logical perspective, the property of walking
quickly is attributed to an entity, John. This property cannot be seen as a
conjunction of two properties, 'being quick' and 'walking'. For sentence (5)
does not mean the same thing as sentence (6):
\begin{enumerate}
\setcounter{enumi}{5}
\item John is walking and John is quick
\end{enumerate}


In logical terms, \textbf{quickly} is an expression which when applied to the
first-order predicate \textbf{walking} result in a new first-order predicate \textbf{walking
quickly}. From a logical point of view, the \textbf{relative adjectives} are
expressions of the same kind. Sentence (7) may be represented in first-order
predicate logic as formula (8)
\begin{enumerate}
\setcounter{enumi}{6}
\item Jumbo is a pink elephant
\item \(Ej\wedge Pj\)
\end{enumerate}


The adjective \textbf{pink} may, in other words, be represented as a standard
first-order predicate. But the same does not apply to relative adjectives
like \textbf{small}. Sentence (9) is the same kind of sentence as (7)
\begin{enumerate}
\setcounter{enumi}{8}
\item Jumbo is a small elephant
\end{enumerate}


But sentence (9) cannot be analyzed as a conjunction of two first-oder
predicates. The formula (10) which we would then obtain:
\begin{enumerate}
\setcounter{enumi}{9}
\item \(Ej\wedge Sj\)
\end{enumerate}


expresses something which is generally false. The relative adjective \textbf{small}
works the same way as the predicate adverbial \textbf{quickly}. When applied to the
predicate \textbf{elephant}, it results in a new predicate \textbf{small elephant}
\subsubsection{Syntax}
\label{sec:org5d992f2}
As our two basic types we have \(e\), which is the type of those expressions
which refer to entities, and \(t\), the type of those expressions which
refer to truth values.
\begin{definition}[]
\(\bT\), the set of types, is the smallest set s.t.
\begin{enumerate}
\item \(e,t\in\bT\)
\item if \(a,b\in\bT\), then \(\la a,b\ra\in\bT\)
\end{enumerate}
\end{definition}

An expression of type \(\la a,b\ra\) is an expression which when applied to
an expression of type \(a\) results in an expression of type \(b\). If \(\alpha\) is
an expression of type \(\la a,b\ra\) and \(\beta\) is an expression of type \(a\),
then \(\alpha(\beta)\) will be an expression of type \(b\). This process of applying
an \(\alpha\) of type \(\la a,b\ra\) to a \(\beta\) of type \(a\) is called
\textbf{(functional) application of \(\alpha\) to \(\beta\)}

The \textbf{vocabulary} of a type-theoretical language L contains some symbols which
are shared by all such languages and a number of symbols which are
characteristic of \(L\). The shared part consists of:
\begin{enumerate}
\item For every type \(a\), an infinite set \(\VAR_a\) of variables of type \(a\)
\item The usual connectives \(\wedge,\vee,\to,\neg,\leftrightarrow\)
\item The quantifiers \(\forall\) and \(\exists\)
\item Two brackets ( and )
\item The symbol for identity =
\end{enumerate}


The part of the vocabulary which is characteristic of \(L\) contains
\begin{enumerate}
\setcounter{enumi}{5}
\item for every type \(a\), a (possibly empty) set \(\CON_a^L\) of
constants of type \(a\)
\end{enumerate}


We will write \(v_a\) for variables of type \(a\) and \(c_a\) for constants
of type \(a\).

\begin{definition}[]
\label{def4.2.2}
\begin{enumerate}
\item If \(\alpha\) is a variable or a constant of type \(a\) in \(L\), then \(\alpha\) is an
expression of type \(a\) in \(L\)
\item If \(\alpha\) is an expression of type \(\la a,b\ra\) in \(L\), and \(\beta\) is an
expression of type \(a\) in \(L\), then \((\alpha(\beta))\) is an expression of
type \(b\) in \(L\)
\item If \(\phi\) and \(\psi\) are expressions of type \(t\) in \(L\), then so are
\(\neg\phi,(\phi\wedge\psi),(\phi\vee\psi)\),\((\phi\to\psi)\) and \(\phi\leftrightarrow\psi\)
\item If \(\phi\) is an expression of type \(t\) in \(L\) and \(v\) is a variable (of
arbitrary type \(a\)), then \(\forall x\phi\) and \(\exists v\phi\) are
expressions of type \(t\) in \(L\)
\item If \(\alpha\) and \(\beta\) are expressions in \(L\) which belong to the same (arbitrary)
type, then \((\alpha=\beta)\) is an expression of type \(t\) in \(L\)
\item Every expression in \(L\) is to be constructed by means of (1) - (5) in a
finite number of steps
\end{enumerate}
\end{definition}

We refer to the set of all expressions in \(L\) of type \(a\) as \(\WE_a^L\)
or, if it is clear which \(L\) is meant, as \(\WE_a\). The \textbf{formulas} are the
elements of \(\WE_t\)
\subsubsection{Semantics}
\label{sec:org82fa0c1}
Given a domain \(D\), one-place predicates are interpreted as the
characteristic functions of subsets of that domain.

The domain of interpretation of expressions of type \(a\), given a domain
\(D\), is written as \(\bD_{a,D}\) and is defined as follows
\begin{definition}[]
\begin{enumerate}
\item \(\bD_{e,D}=D\)
\item \(\bD_{t,D}=\{0,1\}\)
\item \(\bD_{\la a,b\ra,D}=\bD_{b,D}^{\bD_{a,D}}\)
\end{enumerate}
\end{definition}

For example, in the theory of types, a two-place predicate \(L(loves)\) is
an expression of type \(\la e,\la e,t\ra\ra\). The corresponding
interpretation domain \(\bD_{\la e,\la e,t\ra\ra}\) is \((\{0,1\}^D)^D\)

Consider the second-order predicate \(\calc(color)\), which is of type
\(\la\la e,t\ra,t\ra\). The interpretation domain \(\bD_{\la\la
    e,t\ra,t\ra}\) is the set of functions \(\{0,1\}^{\{0,1\}^D}\)

A model \(\bM\) for an language \(L\) for the theory of types consists of a
nonempty domain set \(D\) together with an interpretation function \(I\).
For each type \(a\), \(I\) is a function from \(\CON_a^L\) into \(\bD_{a,D}\).

We must define the concept of \textbf{the interpretation of \(\alpha\) w.r.t. a model \(\bM\)}
\textbf{and an assignment} \(g\), to be written as
\(\llbracket\alpha\rrbracket_{\bM,g}\). The interpretation
function\(\llbracket\;\rrbracket_{\bM,g}\) can be seen as a function which
for all types \(a\), maps \(\WE^L_a\) into \(\bD_{a,D}\).

\begin{definition}[]
\label{def4.2.3}
\begin{enumerate}
\item If \(\alpha\in \CON_a^L\), then
\(\llbracket\alpha\rrbracket_{\bM,g}=I(\alpha)\)

If \(\alpha\in \VAR_a\), then \(\llbracket\alpha\rrbracket_{\bM,g}=g(\alpha)\)

\item If \(\alpha\in \WE^L_{\la a,b\ra},\beta\in \WE^L_a\), then
\(\llbracket\alpha(\beta)\rrbracket_{\bM,g}=\llbracket\alpha\rrbracket_{\bM,g}(
       \llbracket\beta\rrbracket_{\bM,g})\)

\item If \(\phi,\psi\in \WE_t^L\), then

\(\llbracket\neg\phi\rrbracket_{\bM,g}=1\) iff
\(\llbracket\phi\rrbracket_{\bM,g}=0\)

\(\llbracket\phi\wedge\psi\rrbracket_{\bM,g}=1\) iff
\(\llbracket\phi\rrbracket_{\bM,g}=\llbracket\psi\rrbracket_{\bM,g}=1\)

\(\llbracket\phi\to\psi\rrbracket_{\bM,g}=0\) iff
\(\llbracket\phi\rrbracket_{\bM,g}=1\) and
\(\llbracket\psi\rrbracket_{\bM,g}=0\)

\(\llbracket\phi\leftrightarrow\psi\rrbracket_{\bM,g}\) iff
\(\llbracket\phi\rrbracket_{\bM,g}=\llbracket\psi\rrbracket_{\bM,g}\)

\item if \(\phi\in \WE_t^L,v\in \VAR_a\), then

\(\llbracket\forall v\phi\rrbracket_{\bM,g}=1\) iff for all
\(d\in\bD_{a,D}\):
\(\llbracket\phi\rrbracket_{M,g[v/d]}=1\)

\(\llbracket\exists v\phi\rrbracket_{\bM,g}=1\) iff there is at least one
\(d\in\bD_{a,D}\) s.t.: \(\llbracket\phi\rrbracket_{\bM,g[v/d]}=1\)

\item If \(\alpha,\beta\in \WE_a^L\), then
\(\llbracket\alpha=\beta\rrbracket_{\bM,g}=1\) iff
\(\llbracket\alpha\rrbracket_{\bM,g}=\llbracket\beta\rrbracket_{\bM,g}\)
\end{enumerate}
\end{definition}

A sentence \(\phi\) is said to be \textbf{true with respect to} \(\bM\) just in case
\(\llbracket\phi\rrbracket_{\bM}=1\) . A sentence \(\phi\) is said to be
\textbf{universally valid} just in case \(\llbracket\phi\rrbracket_{\bM}=1\) for
every appropriate \(\bM\) and once again the notation is \(\models\phi\). We
also say that two sentences \(\phi\) and \(\psi\) are \textbf{equivalent} iff
\(\models\phi\leftrightarrow\psi\) that is to say iff
\(\llbracket\phi\rrbracket_{\bM}=\llbracket\psi\rrbracket_{\bM}\) for every \(\bM\).

Consider the formula \(W(j)\), our representation of the sentence \emph{John is
walking}. Here \(W\) is a constant of type \(\la e,t\ra\), while \(j\) is a
constant of type \(e\). Hence \(\llbracket W(j)\rrbracket_{\bM,g}=\llbracket
    W\rrbracket_{\bM,g}(\llbracket j\rrbracket_{\bM,g})\). And we have
\(\llbracket W\rrbracket_{\bM,g}=I(W)\) and \(\llbracket
    j\rrbracket_{\bM,g}=I(j)\). According to the definition of the
interpretation function \(I\), we know that \(I(W)\) is an element of the
set of functions \(\bD_t^{\bD_e}=\{0,1\}^D\). And the interpretation of the
constant \(I(j)\) is an element of \(\bD_e\)

As an example of \textbf{higher-order quantification}, consider the formula
\(\exists\calx(\calx(R)\wedge\calx(G))\), the representation of the sentence
\emph{Red and green have something in common}. \(R\) and \(G\) are constants of
type \(\la e,t\ra\) and \(\calx\) is a variable of type \(\la\la
    e,t\ra,t\ra\). The interpretation of
\(\exists\calx(\calx(R)\wedge\calx(G))\) runs as follows:
\(\llbracket\exists\calx(\calx(R)\wedge\calx(G))\rrbracket_{\bM,g}=1\) iff
there is a \(d\in\bD_{\la\la e,t\ra,t\ra}\) s.t.
\(\llbracket\calx(R)\wedge\calx(G)\rrbracket_{\bM,g[\calx/d]}=1\).
\(\bD_{\la\la e,t\ra,t\ra}\) is the set of functions
\(\bD_t^{(\bD_t^{\bD_e})}\).
\(\llbracket\calx(R)\rrbracket_{\bM,g[\calx/d]}=1\) iff
\(\llbracket\calx\rrbracket_{\bM,g[\calx/d]}(\llbracket
    R\rrbracket_{\bM,g[\calx/d]})=1\). Note that
\(\llbracket R\rrbracket_{\bM,g[\calx/d]}=I(R)\) and that
\(\llbracket\calx\rrbracket_{\bM,g[\calx/d]}=g[\calx/d](\calx)=d\)


Consider the formula \((Q(W))(j)\), which is the representation of the
sentence \textbf{John walks quickly} in the theory of types. The adverbial \textbf{quickly}
should be treated as an expression whose application to a predicate results
in another predicate. It is represented by means of a constant \(Q\), which
is of type \(\la\la e,t\ra,\la e,t\ra\ra\). The interpretation of this
composite expression is
\(\llbracket Q(W)\rrbracket_{\bM,g}=\llbracket
    Q\rrbracket_{\bM,g}(\llbracket W\rrbracket_{\bM,g})\), and that is
\(I(Q)I(W)\); \(I(Q)\) is an element of
\(\left(\bD_t^{\bD_e}\right)^{(\bD_t^{\bD_e})}=
    (\{0,1\}^D)^{(\{0,1\}^D)}\)

Note that the above only says what \textbf{kind} of thing the interpretation of an
adverbial like \textbf{quickly} is. But say nothing at all about the relation between
the interpretation of the predicate to which \(Q\) is applied and the
interpretation of the composite predicate which is the result. For example,
the validity of the argument

\begin{enumerate}
\setcounter{enumi}{10}
\item \begin{tabular}{l}
John walks quickly\\
\hline
John walks\\
\end{tabular}
\end{enumerate}


is then not yet guarenteed: in the theory of types, \((Q(W))(j)/W(j)\) is
not a valid argument schema. Also consider the following argument
\begin{enumerate}
\setcounter{enumi}{11}
\item \begin{tabular}{l}
Albert is taller than Bert\\
Bert is taller than Charley\\
\hline
Albert is taller than Charley\\
\end{tabular}
\end{enumerate}


The predicate logic schema corresponding to this is \(Tab,Tbc/Tac\). The
validity of (12) depends essentially on the transitivity of the relation \textbf{is}
\textbf{taller than}

Something similar applies to (11). There too an additional premise is
needed. In this case it would say that whenever \(x\) does \(X\) quickly,
\(x\) does \(X\). This premise can be expressed, in the formalism of the
theory of types, as \(\forall x\forall X((Q(X)(x))\to X(x))\). The argument
schema (13) is indeed valid in the theory of types:
\begin{enumerate}
\item \(\forall x\forall X((Q(X))(x)\to X(x)),(Q(W))(j)/W(j)\)
\end{enumerate}


Such extra premises are known as 'meaning postulates'
\subsection{Categorial Grammar}
\label{sec:orgfb1cb15}
\subsubsection{Characteristics of Categorial Grammar}
\label{sec:org44d51de}
A \textbf{pure categorial grammar} has the following four characteristics:
\begin{enumerate}
\item There is a finite set of \textbf{basic categories}
\item From these basic categories, a set of \textbf{derived categories} is constructed
\item There are either one or two \textbf{syntactic rules} describing the one syntactic
operation of concatenation and determining the category of the result of operation
\item Every lexical element is assigned to a category
\end{enumerate}


Here is a very simple example of a categorial grammar
\begin{enumerate}
\item The basic categories are \(n\) (for 'noun') and \(s\) (for 'sentence')
\item The derived categories may be obtained as follows: If \(A\) and \(B\) are
categories, then \((A\textbackslash B)\) is a category too
\item The syntactic rule is: If \(\alpha\) is an expression of category \(A\), and \(\beta\) is
an expression of category \((A\textbackslash B)\), then \(\alpha\beta\) is an
expression of category \(B\)
\item \emph{John} is of category \(n\); \emph{walks} is of category \(n\textbackslash s\); and
\emph{quickly} is of category \((n\textbackslash s)\textbackslash(n\textbackslash s)\)
\end{enumerate}


According to this categorial grammar
\begin{enumerate}
\setcounter{enumi}{13}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=30pt}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ $\substack{\text{John}\\n}$
$\substack{\text{walks}\\n\textbackslash s}$ ]
\end{tikzpicture}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=70pt}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ $\substack{\text{John}\\n}$
[.$n\textbackslash s$
$\substack{\text{walks}\\n\textbackslash s}$
$\substack{\text{quickly}\\(n\textbackslash s)\textbackslash(n\textbackslash s)}$ ] ]
\end{tikzpicture}
\end{enumerate}


The above example is of a \textbf{undirectional grammar}. You can only work in one
direction, in the sense that if you have an expression of category
\(A\textbackslash B\), then you have to write an expression of type \(A\) on the
\emph{left-hand} side in order to obtain an expression of type \(B\). There are
many expressions which would result in a new expression if something were
written to their right. Take, for example, an adjective like \textbf{poor}. Together
with \textbf{John}, obtained from category \(n\), this gives us \textbf{poor John}. The
definition of derived categories can be modified in the following manner so
as to allow for expressions like this:
\begin{enumerate}
\setcounter{enumi}{4}
\item If \(A\) and \(B\) are categories, then both \((A\textbackslash B)\) and
\((A/B)\) are categories
\end{enumerate}


Thus we obtain a \textbf{bidirectional} categorial grammar. Such a categorial grammar
needs two syntactic rules:
\begin{enumerate}
\setcounter{enumi}{5}
\item \begin{enumerate}
\item If \(\alpha\) is in cateogry \(A\) and \(\beta\) is in cateogry \(A\textbackslash B\), then
\(\alpha\beta\) is in cateogry \(B\)
\item If \(\alpha\) is in category \(A/B\) and \(\beta\) is in category \(B\), then
\(\alpha\beta\) is in category \(A\)
\end{enumerate}
\end{enumerate}


In the example given in (16), both kinds of derived categories are involved
\begin{enumerate}
\setcounter{enumi}{15}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=90pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$
[.$n$ {poor\\$n/ n$} {John\\$n$} ]
[.$n\textbackslash s$ {loves\\$(n\textbackslash s)/n$}
[.$n$ {lucky\\$n/ n$} {Mary\\$n$} ] ] ]
\end{tikzpicture}
\end{enumerate}


In other variant of categorical grammar, expressions in derived categories
may be concatenated with several other expressions simultaneously.
\begin{enumerate}
\setcounter{enumi}{6}
\item If \(A,B,C\) are categories, then \(A\textbackslash B/C\) is a category
\item If \(\alpha\) is in cateogry \(A\), \(\beta\) is in category \(A\textbackslash B/C\), and
\(\gamma\) is in category \(C\), then \(\alpha\beta\gamma\) is in category \(B\)
\end{enumerate}


In this way, the transitive verb \textbf{loves} may be categories as
\(n\textbackslash s/n\), instead of as \((n\textbackslash s)/ n\)
\begin{enumerate}
\setcounter{enumi}{16}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=40pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ {John\\$n$} {loves\\$n\textbackslash s/n$}
{Mary\\$n$} ]
\end{tikzpicture}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=70pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ {John\\$n$}
[.$n\textbackslash s$ {loves\\$(n\textbackslash s)/n$}
{Mary\\$n$} ] ]
\end{tikzpicture}
\end{enumerate}


The analysis depicted in (17) attributes less structure to this example
sentence than the analysis in figure (18). In (18), \textbf{loves Mary} is treated as
a single constituent which is not so in (17). Generally speaking, an
analysis like that in (18) will be preferred. An exception is, for example,
formed by coordinative conjunctions, for which the categorization
\(s\textbackslash s/s\) is to be preferred over \(s\textbackslash(s/s)\) or
\((s\textbackslash s)/s\).
\begin{enumerate}
\setcounter{enumi}{18}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=70pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$
[.$s$ {Mary\\$n$} {sings\\$n\textbackslash s$} ]
{and\\$s\textbackslash s/s$}
[.$s$ {John\\$n$} {dances\\$n\textbackslash s $} ] ]
\end{tikzpicture}
\item \begin{tikzpicture}
\tikzset{grow= up}
\tikzset{frontier/.style={distance from root=90pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ ]
[.$s$
[.$s/ s$
[.$s$ {Mary\\$n$} {sings\\$n\textbackslash s$} ]
{and\\$s\textbackslash (s/s)$} ]
[.$s$ {John\\$n$} {dances\\$n\textbackslash s$} ] ]
\end{tikzpicture}
\end{enumerate}



The difference between a bidirectional categorial grammar and a context-free
grammar is in essence the following: A bidirectional categorial grammar
always indicates which of a given pair of constituents is dependent on the
other, whereas a context-free grammar need not always provide this information
\subsubsection{The Descriptive Adequacy of Categorial Grammar}
\label{sec:org1ea78eb}
Compare sentences (22) and (23):
\begin{enumerate}
\setcounter{enumi}{21}
\item The job was quickly finished
\item The job was finished quickly
\end{enumerate}


In (22), the constituent \textbf{was finished} occurs discontinuously, that is, it is
interrupted by another expression. This contrasts with its continuity in
(23). In a categorial grammar in its pure form, this presents a problem.
Hence we are foreced to consider \textbf{was} and \textbf{finished} as separate lexical items
and to place each of them in (at least) two different cateogries, so they
can form both continuous and discontinuous constituents. Sentence (24) gives
another example of this phenomenon
\begin{enumerate}
\setcounter{enumi}{23}
\item John never calls up Mary, so she calls him up instead
\end{enumerate}


Here we have both a continuous and a discontinuous occurrence of the
constituent \textbf{calls up}. Here too, in a categorial grammar there is no choice
but to classify \textbf{calls up}, \textbf{calls} and \textbf{up} separately, as three distinct lexical items.

A second phenomenon which presents problems for pure categorial grammars and
context-free grammars centers around the intuition that sentence (25) means
the same as sentence (26):
\begin{enumerate}
\setcounter{enumi}{24}
\item John loves Mary, and Jack, Jill
\item John loves Mary, and Jack loves Jill
\end{enumerate}


(25) is derived from (26) by leaving out the word \textbf{loves} in the second
conjunct. Another conjecture is that the 'missing part' of (25) gets filled
in during the process of interpretation. Either way, leaving out a
constituent or filling one in introduces context-dependency into the
picture, since the piece to be left out or filled in must always be present
somewhere else in the structure.

A third phenomenon which illustrates that the limited generative capacity o
context-free grammars and pure categorial grammars may lead to unituitive
result is that of \textbf{word order}. Both kinds of grammar decree a fixed word
order and hence seem to fail as adequate descriptive tools for languages in
which it is not word order.
\subsubsection{Categorial Grammar and the Theory of Types}
\label{sec:org2ada5df}
\begin{enumerate}
\setcounter{enumi}{26}
\item \begin{tikzpicture}
\tikzset{grow' = up}
\tikzset{frontier/.style={distance from root=40pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ {John\\$n$}
{swims\\$n\textbackslash s$} ]
\begin{scope}[yshift=-2.3cm]
\Tree [.$s$ {Swimming\\$n\textbackslash s$}
{is healthy\\$(n\textbackslash s)\textbackslash s$} ]
\end{scope}
\begin{scope}
\node [xshift=3.5cm,yshift=1cm] {$(S_{\la e,t\ra}(j_e))$};
\node  [xshift= 3.5cm,yshift=-1.3cm] {$H_{\la\la e,t\ra,t\ra}(S_{\la e,t\ra})$};
\node [yshift=-3.5cm] {\textit{Categorial grammar}};
\node [yshift=-3.5cm,xshift=3.5cm] {\textit{Theory of types}};
\end{scope}
\end{tikzpicture}
\end{enumerate}
\subsection{\(Î»\)-Abstraction}
\label{sec:org994edd1}
\subsubsection{The \(Î»\)-Operator}
\label{sec:orgc9eaf0a}
\begin{enumerate}
\setcounter{enumi}{28}
\item Jogging is healthy
\end{enumerate}


A translation of this sentence into the theory of types may be obtained as
follows. Given that \textbf{jogging} expresses a property of individuals, the
expression may be translated as a predicate constant \(J\) of type \(\la
    e,t\ra\). \textbf{Healthy} expresses, a property of properties of individuals and is
as such to be rendered as a constant \(\calh\) of type \(\la\la e,t\ra,t\).
The whole of (29) is then to be translated as the formula \(\calh(J)\)

\begin{enumerate}
\setcounter{enumi}{29}
\item Not smoking is healthy
\item Drinking and driving is unwise
\item John admires John
\item John admires himself
\end{enumerate}


In order to account for constructions like these, the following rule is
added to the syntax of the theory of types as given in definition 2 in
\ref{def4.2.2}
\begin{enumerate}
\setcounter{enumi}{6}
\item If \(\alpha\) is expression of type \(a\) in \(L\), and \(v\) is a variable
of type \(b\), then \(\lambda v\alpha\) is expression of type \(\la b,a\ra\) in
\(L\)
\end{enumerate}


Let \(W\) be a constant of type \(\la e,t\ra\), and let \(x\) be a variable
of type \(e\). Then \(W(x)\) is a formula in which \(x\) appears as a free
variable. We can form the expression \(\lambda x(W(x))\) of type \(\la e,t\ra\).
We say that the expression \(\lambda x(W(x))\) has been formed from the expression
\(W(x)\) by \textbf{abstraction over} the free variable \(x\). We say that the free
occurrences of the variable \(x\) in \(\alpha\) are \textbf{bound} in \(\lambda x\alpha\) by the
\textbf{\(\lambda\)-operator} \(\lambda x\)

The interpretation of a \(\lambda\)-abstraction \(\lambda x_b\alpha_a\) is a
function. For this reason, \(\lambda\)-abstraction is also referred to as
\textbf{functional abstraction}.

Now we add the following clause to Definition 
\begin{enumerate}
\setcounter{enumi}{5}
\item If \(\alpha\in\WE^L_a\) and \(v\in\VAR_b\), then \(\llbracket \lambda
       v\alpha\rrbracket_{\bM,g}\) is that function \(h\in\bD_a^{\bD_b}\) s.t.
for all \(d\in\bD_b\):\(h(d)=\llbracket\alpha\rrbracket_{\bM,g[v/d]}\)
\end{enumerate}


Sentence (30), \emph{Not smoking is healthy}, can be translated as follows. Let
\(S\) be the translation of \emph{smoking}. This is a constant of type \(\la
    e,t\ra\). And let \(x\) be a variable of type \(x\). We obtain the
expression \(\lambda x\neg S(x)\) of type \(\la e,t\ra\). The whole of (30) may
now be obtained by applying the second-order predicate \(\calh\). The result
is \(\calh(\lambda x\neg S(x))\)
\subsubsection{\(Î»\)-Conversion}
\label{sec:org72ee213}
The general notation for the result of replacing all free occurrences of a
variable \(v\) in an expression \(\beta\) by an expression \(\gamma\) is \([\gamma/v]\beta\)

\begin{definition}[]
A variable \(v'\) is \textbf{free for \(v\)}  in the expression \(\beta\) iff no free
occurrence of \(v\) in \(\beta\) is within the scope of a quantifier \(\exists v'\)
or \(\forall v'\) or a \(\lambda\)-operator \(\lambda v'\)
\end{definition}

\begin{theorem}[]
If all variables which occurs as free variables in \(\gamma\) are free for \(v\) in
\(\beta\), then \(\lambda v\beta(\gamma)\) and \([\gamma/v]\beta\) are equivalent
\end{theorem}
\subsubsection{The \(Î»\)-Operator and Compositionality}
\label{sec:org130acb5}
The main purpose of translating a natural language into a formal language is
to obtain a semantic interpretation of the former via the semantics of the
latter. For the meaning of a correct translation is the same as the meaning
of what is translated. In order for the semantic interpretation to be
satisfactory, it is necessary that the process of translation comply to
certain requirements. Among these, two important requirements are that the
process be \textbf{explicit} and that it can be \textbf{specified in a finite manner}.  The
requirement that is be explicit means that it may not in any way rely on the
knowledge or creativity of the translator: it must be such that it could, at
least in principle, be automated. Furthermore, the translation process,
though essentially finite,must translate a potentially infinite number of
sentences.

One way of doing this is to stay closed to the syntactic rules of the
natural language in question, which are finite in number. Here we assume
that translations are available for all of the lexical elements of the
language, which are finite in number. The for each syntactic rule saying how
expressions may be combined to form composite expressions we formulate a
parallel rule, which says how the translations of these expressions may be
combined to give the translations of the composite expressions.

Now it should be clear that the way we have translated natural language
sentences into standard predicate logic up until now is neither explicit nor
compositional.
\begin{enumerate}
\setcounter{enumi}{34}
\item John smokes and drinks
\item \(Sj\wedge Dj\)
\end{enumerate}


The way of translating is not explicit, in that essential use is made of our
knowledge of the meaning of (35), in particular our knowledge of the fact
that (35) expressions a conjunction of two sentences. And it is not
compositional, in that no account is given of how the translation of (35) is
built up from the translations of \textbf{John} and \textbf{smokes and drinks}, or how the
translation of the \textbf{smokes and drinks} is built up from the translations of
\textbf{smokes} and \textbf{drinks}. Given that the lexical elements of (35) are rendered as
follows: \(John:j,smokes:S,drinks:D\), the phrase \textbf{smokes and drinks} can be
rendered as (37), while the whole of (35) translates as (38)
\begin{enumerate}
\setcounter{enumi}{36}
\item \(\lambda x(S(x)\wedge D(x))\)
\item \(\lambda x(S(x)\wedge D(x))(j)\)
\end{enumerate}


We shall introduce the first-order quantifiers \(\exists\) and \(\forall\)
categorematically by treating them as second-order predicates, that is to
say, as expressions of type \(\la\la e,t\ra,t\ra\)
\begin{center}
\(I(\exists)\) is that function \(f_{\exists}\in\{0,1\}^{(\{0,1\}^D)}\) s.t.
if \(h\in\{0,1\}^D\),then \par
\(f_\exists(h)=1\) iff there is a \(d\in D\) s.t. \(h(d)=1\) \par
\(I(\forall)\) is that function \(f_{\forall}\in\{0,1\}^{(\{0,1\}^D)}\) s.t.
if \(h\in\{0,1\}^D\),then \par
\(f_\exists(h)=1\) iff for all \(d\in D\) : \(h(d)=1\) 
\end{center}
In other words, \(I(\exists)\) is (the characteristic function of) the set
of non-empty subsets of, that is \(\{A\mid A\subseteq D\&A\neq\emptyset\}\).
And \(I(\forall)\) is (the characteristic function of) \(\{D\}\)

We have interpreted \(\exists\) as the set of all nonempty subsets of \(D\).
This means that the quantifier \(\exists\) is equivalent to the expression
\(\lambda Y\exists x(Y(x))\) in the theory of types.
\section{The Intensional Theory of Types}
\label{sec:org7b3a94a}
\end{document}
