#+TITLE: Logic Language And Meaning
#+AUTHOR: L. T. E. Gamut

#+EXPORT_FILE_NAME: ../latex/LogicLanguageAndMeaning/LogicLanguageAndMeaning.tex
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \DeclareMathOperator{\VAR}{VAR}
#+LATEX_HEADER: \DeclareMathOperator{\CON}{CON}
#+LATEX_HEADER: \DeclareMathOperator{\WE}{WE}
#+LATEX_HEADER: \DeclareMathOperator{\Int}{Int}
#+LATEX_HEADER: \DeclareMathOperator{\ICE}{ICE}
* The Theory of Types and Categorical Grammar

** The Theory of Types
*** Type Distinctions in Natural Language
   1. If John is self-satisfied, then there is at least one thing he has in
      common with Peter


   Sentence (1) contains quantification over properties.

   2. [@2] Santa Claus has all the attributes of a sadist


   If we are to quantify not only over entities but also over properties of
   entities, then we need to extend predicate logic by introducing variables
   other than the ones we already have, which only range over entities. Besides
   predicate letters, we need *predicate variables*, so that we can quantify over
   this kind of variable in the syntax. Letting \(X\) be such a variable, (1)
   and (2) may be represented as in (3) and (4):
   3. [@3] \(Zj\to\exists X(Xj\wedge Xp)\)
   4. \(\forall X(\forall x(Sx\to Xx)\to Xs)\)


   But second-order predicate logic does not exhaust the expressive power of
   natural language. For not only are there natural language sentences which
   quantify over properties of entities, but there are also sentences which
   attribute properties to these properties of entities in turn.The predicate
   *red* expresses a property of individuals, so the predicate *color* expresses a
   property of properties of individuals. So in a sentence like *Red is a color*,
   which we represent as \(\calc(R)\), the second-order predicate *color* is
   applied to the first-order predicate *red*. We can also quantify over these
   properties of properties, as in *Red has something in common with green*.

   Besides higher-order predicates, there are other kinds of expressions which
   for linguistic purposes may usefully be added to predicate logic.

   Our first class of examples is formed by expressions with *predicate
   adverbials*
   5. [@5] John is walking quickly


   The expression *quickly* is, form a linguistic perspective, a modifier acting
   on the verb *is walking*. From a logical perspective, the property of walking
   quickly is attributed to an entity, John. This property cannot be seen as a
   conjunction of two properties, 'being quick' and 'walking'. For sentence (5)
   does not mean the same thing as sentence (6):
   6. [@6] John is walking and John is quick


   In logical terms, *quickly* is an expression which when applied to the
   first-order predicate *walking* result in a new first-order predicate *walking
   quickly*. From a logical point of view, the *relative adjectives* are
   expressions of the same kind. Sentence (7) may be represented in first-order
   predicate logic as formula (8)
   7. [@7] Jumbo is a pink elephant
   8. \(Ej\wedge Pj\)


   The adjective *pink* may, in other words, be represented as a standard
   first-order predicate. But the same does not apply to relative adjectives
   like *small*. Sentence (9) is the same kind of sentence as (7)
   9. [@9] Jumbo is a small elephant


   But sentence (9) cannot be analyzed as a conjunction of two first-oder
   predicates. The formula (10) which we would then obtain:
   10. [@10] \(Ej\wedge Sj\)


   expresses something which is generally false. The relative adjective *small*
   works the same way as the predicate adverbial *quickly*. When applied to the
   predicate *elephant*, it results in a new predicate *small elephant*
*** Syntax
    As our two basic types we have \(e\), which is the type of those expressions
    which refer to entities, and \(t\), the type of those expressions which
    refer to truth values.
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(\bT\), the set of types, is the smallest set s.t.
    1. \(e,t\in\bT\)
    2. if \(a,b\in\bT\), then \(\la a,b\ra\in\bT\)
    #+END_definition

    An expression of type \(\la a,b\ra\) is an expression which when applied to
    an expression of type \(a\) results in an expression of type \(b\). If \alpha is
    an expression of type \(\la a,b\ra\) and \beta is an expression of type \(a\),
    then \(\alpha(\beta)\) will be an expression of type \(b\). This process of applying
    an \alpha of type \(\la a,b\ra\) to a \beta of type \(a\) is called
    *(functional) application of \alpha to \beta*

    The *vocabulary* of a type-theoretical language L contains some symbols which
    are shared by all such languages and a number of symbols which are
    characteristic of \(L\). The shared part consists of:
    1. For every type \(a\), an infinite set \(\VAR_a\) of variables of type \(a\)
    2. The usual connectives \(\wedge,\vee,\to,\neg,\leftrightarrow\)
    3. The quantifiers \(\forall\) and \(\exists\)
    4. Two brackets ( and )
    5. The symbol for identity =


    The part of the vocabulary which is characteristic of \(L\) contains
    6. [@6] for every type \(a\), a (possibly empty) set \(\CON_a^L\) of
       constants of type \(a\)


    We will write \(v_a\) for variables of type \(a\) and \(c_a\) for constants
    of type \(a\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:def4.2.2
    1. If \alpha is a variable or a constant of type \(a\) in \(L\), then \alpha is an
       expression of type \(a\) in \(L\)
    2. If \alpha is an expression of type \(\la a,b\ra\) in \(L\), and \beta is an
       expression of type \(a\) in \(L\), then \((\alpha(\beta))\) is an expression of
       type \(b\) in \(L\)
    3. If \phi and \psi are expressions of type \(t\) in \(L\), then so are
       \(\neg\phi,(\phi\wedge\psi),(\phi\vee\psi)\),\((\phi\to\psi)\) and \(\phi\leftrightarrow\psi\)
    4. If \phi is an expression of type \(t\) in \(L\) and \(v\) is a variable (of
       arbitrary type \(a\)), then \(\forall x\phi\) and \(\exists v\phi\) are
       expressions of type \(t\) in \(L\)
    5. If \alpha and \beta are expressions in \(L\) which belong to the same (arbitrary)
       type, then \((\alpha=\beta)\) is an expression of type \(t\) in \(L\)
    6. Every expression in \(L\) is to be constructed by means of (1) - (5) in a
       finite number of steps
    #+END_definition

    We refer to the set of all expressions in \(L\) of type \(a\) as \(\WE_a^L\)
    or, if it is clear which \(L\) is meant, as \(\WE_a\). The *formulas* are the
    elements of \(\WE_t\)
*** Semantics
    Given a domain \(D\), one-place predicates are interpreted as the
    characteristic functions of subsets of that domain.

    The domain of interpretation of expressions of type \(a\), given a domain
    \(D\), is written as \(\bD_{a,D}\) and is defined as follows
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. \(\bD_{e,D}=D\)
    2. \(\bD_{t,D}=\{0,1\}\)
    3. \(\bD_{\la a,b\ra,D}=\bD_{b,D}^{\bD_{a,D}}\)
    #+END_definition

    For example, in the theory of types, a two-place predicate \(L(loves)\) is
    an expression of type \(\la e,\la e,t\ra\ra\). The corresponding
    interpretation domain \(\bD_{\la e,\la e,t\ra\ra}\) is \((\{0,1\}^D)^D\)

    Consider the second-order predicate \(\calc(color)\), which is of type
    \(\la\la e,t\ra,t\ra\). The interpretation domain \(\bD_{\la\la
    e,t\ra,t\ra}\) is the set of functions \(\{0,1\}^{\{0,1\}^D}\)

    A model \(\bM\) for an language \(L\) for the theory of types consists of a
    nonempty domain set \(D\) together with an interpretation function \(I\).
    For each type \(a\), \(I\) is a function from \(\CON_a^L\) into \(\bD_{a,D}\).

    We must define the concept of *the interpretation of \alpha w.r.t. a model \(\bM\)*
    *and an assignment* \(g\), to be written as
    \(\llbracket\alpha\rrbracket_{\bM,g}\). The interpretation
    function\(\llbracket\;\rrbracket_{\bM,g}\) can be seen as a function which
    for all types \(a\), maps \(\WE^L_a\) into \(\bD_{a,D}\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:def4.2.3
    1. If \(\alpha\in \CON_a^L\), then
       \(\llbracket\alpha\rrbracket_{\bM,g}=I(\alpha)\)

       If \(\alpha\in \VAR_a\), then \(\llbracket\alpha\rrbracket_{\bM,g}=g(\alpha)\)

    2. If \(\alpha\in \WE^L_{\la a,b\ra},\beta\in \WE^L_a\), then
       \(\llbracket\alpha(\beta)\rrbracket_{\bM,g}=\llbracket\alpha\rrbracket_{\bM,g}(
       \llbracket\beta\rrbracket_{\bM,g})\)

    3. If \(\phi,\psi\in \WE_t^L\), then

       \(\llbracket\neg\phi\rrbracket_{\bM,g}=1\) iff
       \(\llbracket\phi\rrbracket_{\bM,g}=0\)

       \(\llbracket\phi\wedge\psi\rrbracket_{\bM,g}=1\) iff
       \(\llbracket\phi\rrbracket_{\bM,g}=\llbracket\psi\rrbracket_{\bM,g}=1\)

       \(\llbracket\phi\to\psi\rrbracket_{\bM,g}=0\) iff
       \(\llbracket\phi\rrbracket_{\bM,g}=1\) and
       \(\llbracket\psi\rrbracket_{\bM,g}=0\)

       \(\llbracket\phi\leftrightarrow\psi\rrbracket_{\bM,g}\) iff
       \(\llbracket\phi\rrbracket_{\bM,g}=\llbracket\psi\rrbracket_{\bM,g}\)

    4. if \(\phi\in \WE_t^L,v\in \VAR_a\), then

       \(\llbracket\forall v\phi\rrbracket_{\bM,g}=1\) iff for all
       \(d\in\bD_{a,D}\):
       \(\llbracket\phi\rrbracket_{\bM,g[v/d]}=1\)

       \(\llbracket\exists v\phi\rrbracket_{\bM,g}=1\) iff there is at least one
       \(d\in\bD_{a,D}\) s.t.: \(\llbracket\phi\rrbracket_{\bM,g[v/d]}=1\)

    5. If \(\alpha,\beta\in \WE_a^L\), then
       \(\llbracket\alpha=\beta\rrbracket_{\bM,g}=1\) iff
       \(\llbracket\alpha\rrbracket_{\bM,g}=\llbracket\beta\rrbracket_{\bM,g}\)
    #+END_definition

    A sentence \phi is said to be *true with respect to* \(\bM\) just in case
    \(\llbracket\phi\rrbracket_{\bM}=1\) . A sentence \phi is said to be
    *universally valid* just in case \(\llbracket\phi\rrbracket_{\bM}=1\) for
    every appropriate \(\bM\) and once again the notation is \(\models\phi\). We
    also say that two sentences \phi and \psi are *equivalent* iff
    \(\models\phi\leftrightarrow\psi\) that is to say iff
    \(\llbracket\phi\rrbracket_{\bM}=\llbracket\psi\rrbracket_{\bM}\) for every \(\bM\).

    Consider the formula \(W(j)\), our representation of the sentence /John is
    walking/. Here \(W\) is a constant of type \(\la e,t\ra\), while \(j\) is a
    constant of type \(e\). Hence \(\llbracket W(j)\rrbracket_{\bM,g}=\llbracket
    W\rrbracket_{\bM,g}(\llbracket j\rrbracket_{\bM,g})\). And we have
    \(\llbracket W\rrbracket_{\bM,g}=I(W)\) and \(\llbracket
    j\rrbracket_{\bM,g}=I(j)\). According to the definition of the
    interpretation function \(I\), we know that \(I(W)\) is an element of the
    set of functions \(\bD_t^{\bD_e}=\{0,1\}^D\). And the interpretation of the
    constant \(I(j)\) is an element of \(\bD_e\)

    As an example of *higher-order quantification*, consider the formula
    \(\exists\calx(\calx(R)\wedge\calx(G))\), the representation of the sentence
    /Red and green have something in common/. \(R\) and \(G\) are constants of
    type \(\la e,t\ra\) and \(\calx\) is a variable of type \(\la\la
    e,t\ra,t\ra\). The interpretation of
    \(\exists\calx(\calx(R)\wedge\calx(G))\) runs as follows:
    \(\llbracket\exists\calx(\calx(R)\wedge\calx(G))\rrbracket_{\bM,g}=1\) iff
    there is a \(d\in\bD_{\la\la e,t\ra,t\ra}\) s.t.
    \(\llbracket\calx(R)\wedge\calx(G)\rrbracket_{\bM,g[\calx/d]}=1\).
    \(\bD_{\la\la e,t\ra,t\ra}\) is the set of functions
    \(\bD_t^{(\bD_t^{\bD_e})}\).
    \(\llbracket\calx(R)\rrbracket_{\bM,g[\calx/d]}=1\) iff
    \(\llbracket\calx\rrbracket_{\bM,g[\calx/d]}(\llbracket
    R\rrbracket_{\bM,g[\calx/d]})=1\). Note that
    \(\llbracket R\rrbracket_{\bM,g[\calx/d]}=I(R)\) and that
    \(\llbracket\calx\rrbracket_{\bM,g[\calx/d]}=g[\calx/d](\calx)=d\)


    Consider the formula \((Q(W))(j)\), which is the representation of the
    sentence *John walks quickly* in the theory of types. The adverbial *quickly*
    should be treated as an expression whose application to a predicate results
    in another predicate. It is represented by means of a constant \(Q\), which
    is of type \(\la\la e,t\ra,\la e,t\ra\ra\). The interpretation of this
    composite expression is
    \(\llbracket Q(W)\rrbracket_{\bM,g}=\llbracket
    Q\rrbracket_{\bM,g}(\llbracket W\rrbracket_{\bM,g})\), and that is
    \(I(Q)I(W)\); \(I(Q)\) is an element of
    \(\left(\bD_t^{\bD_e}\right)^{(\bD_t^{\bD_e})}=
    (\{0,1\}^D)^{(\{0,1\}^D)}\)

    Note that the above only says what *kind* of thing the interpretation of an
    adverbial like *quickly* is. But say nothing at all about the relation between
    the interpretation of the predicate to which \(Q\) is applied and the
    interpretation of the composite predicate which is the result. For example,
    the validity of the argument

    11. [@11]
        #+ATTR_LATEX: :center nil
        | John walks quickly |
        |--------------------|
        | John walks         |


    is then not yet guarenteed: in the theory of types, \((Q(W))(j)/W(j)\) is
    not a valid argument schema. Also consider the following argument
    12. [@12]
        #+ATTR_LATEX: :center nil
        | Albert is taller than Bert  |
        | Bert is taller than Charley |
        |-----------------------------|
        | Albert is taller than Charley |


    The predicate logic schema corresponding to this is \(Tab,Tbc/Tac\). The
    validity of (12) depends essentially on the transitivity of the relation *is*
    *taller than*

    Something similar applies to (11). There too an additional premise is
    needed. In this case it would say that whenever \(x\) does \(X\) quickly,
    \(x\) does \(X\). This premise can be expressed, in the formalism of the
    theory of types, as \(\forall x\forall X((Q(X)(x))\to X(x))\). The argument
    schema (13) is indeed valid in the theory of types:
    13. \(\forall x\forall X((Q(X))(x)\to X(x)),(Q(W))(j)/W(j)\)


    Such extra premises are known as 'meaning postulates'
** Categorial Grammar
*** Characteristics of Categorial Grammar
    A *pure categorial grammar* has the following four characteristics:
    1. There is a finite set of *basic categories*
    2. From these basic categories, a set of *derived categories* is constructed
    3. There are either one or two *syntactic rules* describing the one syntactic
       operation of concatenation and determining the category of the result of operation
    4. Every lexical element is assigned to a category


    Here is a very simple example of a categorial grammar
    1. The basic categories are \(n\) (for 'noun') and \(s\) (for 'sentence')
    2. The derived categories may be obtained as follows: If \(A\) and \(B\) are
       categories, then \((A\textbackslash B)\) is a category too
    3. The syntactic rule is: If \alpha is an expression of category \(A\), and \beta is
       an expression of category \((A\textbackslash B)\), then \(\alpha\beta\) is an
       expression of category \(B\)
    4. /John/ is of category \(n\); /walks/ is of category \(n\textbackslash s\); and
       /quickly/ is of category \((n\textbackslash s)\textbackslash(n\textbackslash s)\)


    According to this categorial grammar
    14. [@14]
        \begin{tikzpicture}
        \tikzset{grow' = up}
        \tikzset{frontier/.style={distance from root=30pt}}
        \tikzset{edge from parent/.style=
        {draw,
        edge from parent path={(\tikzparentnode.north)
        -- +(0,6pt)
        -| (\tikzchildnode)}}}
        \Tree [.$s$ $\substack{\text{John}\\n}$
        $\substack{\text{walks}\\n\textbackslash s}$ ]
        \end{tikzpicture}
    15. 
         \begin{tikzpicture}
         \tikzset{grow' = up}
         \tikzset{frontier/.style={distance from root=70pt}}
         \tikzset{edge from parent/.style=
         {draw,
         edge from parent path={(\tikzparentnode.north)
         -- +(0,6pt)
         -| (\tikzchildnode)}}}
         \Tree [.$s$ $\substack{\text{John}\\n}$
         [.$n\textbackslash s$
         $\substack{\text{walks}\\n\textbackslash s}$
         $\substack{\text{quickly}\\(n\textbackslash s)\textbackslash(n\textbackslash s)}$ ] ]
         \end{tikzpicture}


    The above example is of a *undirectional grammar*. You can only work in one
    direction, in the sense that if you have an expression of category
    \(A\textbackslash B\), then you have to write an expression of type \(A\) on the
    /left-hand/ side in order to obtain an expression of type \(B\). There are
    many expressions which would result in a new expression if something were
    written to their right. Take, for example, an adjective like *poor*. Together
    with *John*, obtained from category \(n\), this gives us *poor John*. The
    definition of derived categories can be modified in the following manner so
    as to allow for expressions like this:
    5. [@5] If \(A\) and \(B\) are categories, then both \((A\textbackslash B)\) and
       \((A/B)\) are categories


    Thus we obtain a *bidirectional* categorial grammar. Such a categorial grammar
    needs two syntactic rules:
    6. [@6]
       1. If \alpha is in cateogry \(A\) and \beta is in cateogry \(A\textbackslash B\), then
          \(\alpha\beta\) is in cateogry \(B\)
       2. If \alpha is in category \(A/B\) and \beta is in category \(B\), then
          \(\alpha\beta\) is in category \(A\)


    In the example given in (16), both kinds of derived categories are involved
    16. [@16] 
         \begin{tikzpicture}
         \tikzset{grow' = up}
         \tikzset{frontier/.style={distance from root=90pt}}
         \tikzset{level distance=25pt}
         \tikzset{every tree node/.style={align=center,anchor=north}}
         \tikzset{edge from parent/.style=
         {draw,
         edge from parent path={(\tikzparentnode.north)
         -- +(0,6pt)
         -| (\tikzchildnode)}}}
         \Tree [.$s$
         [.$n$ {poor\\$n/ n$} {John\\$n$} ]
         [.$n\textbackslash s$ {loves\\$(n\textbackslash s)/n$}
         [.$n$ {lucky\\$n/ n$} {Mary\\$n$} ] ] ]
         \end{tikzpicture}


    In other variant of categorical grammar, expressions in derived categories
    may be concatenated with several other expressions simultaneously.
    7. [@7] If \(A,B,C\) are categories, then \(A\textbackslash B/C\) is a category
    8. If \alpha is in cateogry \(A\), \beta is in category \(A\textbackslash B/C\), and
       \gamma is in category \(C\), then \(\alpha\beta\gamma\) is in category \(B\)


    In this way, the transitive verb *loves* may be categories as
    \(n\textbackslash s/n\), instead of as \((n\textbackslash s)/ n\)
    17. [@17]
        \begin{tikzpicture}
        \tikzset{grow' = up}
        \tikzset{frontier/.style={distance from root=40pt}}
        \tikzset{level distance=25pt}
        \tikzset{every tree node/.style={align=center,anchor=north}}
        \tikzset{edge from parent/.style=
        {draw,
        edge from parent path={(\tikzparentnode.north)
        -- +(0,6pt)
        -| (\tikzchildnode)}}}
        \Tree [.$s$ {John\\$n$} {loves\\$n\textbackslash s/n$}
        {Mary\\$n$} ]
        \end{tikzpicture}
    18. 
        \begin{tikzpicture}
        \tikzset{grow' = up}
        \tikzset{frontier/.style={distance from root=70pt}}
        \tikzset{level distance=25pt}
        \tikzset{every tree node/.style={align=center,anchor=north}}
        \tikzset{edge from parent/.style=
        {draw,
        edge from parent path={(\tikzparentnode.north)
        -- +(0,6pt)
        -| (\tikzchildnode)}}}
        \Tree [.$s$ {John\\$n$}
        [.$n\textbackslash s$ {loves\\$(n\textbackslash s)/n$}
        {Mary\\$n$} ] ]
        \end{tikzpicture}


    The analysis depicted in (17) attributes less structure to this example
    sentence than the analysis in figure (18). In (18), *loves Mary* is treated as
    a single constituent which is not so in (17). Generally speaking, an
    analysis like that in (18) will be preferred. An exception is, for example,
    formed by coordinative conjunctions, for which the categorization
    \(s\textbackslash s/s\) is to be preferred over \(s\textbackslash(s/s)\) or
    \((s\textbackslash s)/s\).
    19. [@19]
        \begin{tikzpicture}
        \tikzset{grow' = up}
        \tikzset{frontier/.style={distance from root=70pt}}
        \tikzset{level distance=25pt}
        \tikzset{every tree node/.style={align=center,anchor=north}}
        \tikzset{edge from parent/.style=
        {draw,
        edge from parent path={(\tikzparentnode.north)
        -- +(0,6pt)
        -| (\tikzchildnode)}}}
        \Tree [.$s$
        [.$s$ {Mary\\$n$} {sings\\$n\textbackslash s$} ]
        {and\\$s\textbackslash s/s$}
        [.$s$ {John\\$n$} {dances\\$n\textbackslash s $} ] ]
        \end{tikzpicture}
    20. 
        #+BEGIN_SRC latex
\begin{tikzpicture}
\tikzset{grow= up}
\tikzset{frontier/.style={distance from root=90pt}}
\tikzset{level distance=25pt}
\tikzset{every tree node/.style={align=center,anchor=north}}
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.north)
-- +(0,6pt)
-| (\tikzchildnode)}}}
\Tree [.$s$ ]
[.$s$
[.$s/ s$
[.$s$ {Mary\\$n$} {sings\\$n\textbackslash s$} ]
{and\\$s\textbackslash (s/s)$} ]
[.$s$ {John\\$n$} {dances\\$n\textbackslash s$} ] ]
\end{tikzpicture}
        #+END_SRC



    The difference between a bidirectional categorial grammar and a context-free
    grammar is in essence the following: A bidirectional categorial grammar
    always indicates which of a given pair of constituents is dependent on the
    other, whereas a context-free grammar need not always provide this information
*** The Descriptive Adequacy of Categorial Grammar
    Compare sentences (22) and (23):
    22. [@22] The job was quickly finished
    23. The job was finished quickly


    In (22), the constituent *was finished* occurs discontinuously, that is, it is
    interrupted by another expression. This contrasts with its continuity in
    (23). In a categorial grammar in its pure form, this presents a problem.
    Hence we are foreced to consider *was* and *finished* as separate lexical items
    and to place each of them in (at least) two different cateogries, so they
    can form both continuous and discontinuous constituents. Sentence (24) gives
    another example of this phenomenon
    24. [@24] John never calls up Mary, so she calls him up instead


    Here we have both a continuous and a discontinuous occurrence of the
    constituent *calls up*. Here too, in a categorial grammar there is no choice
    but to classify *calls up*, *calls* and *up* separately, as three distinct lexical items.

    A second phenomenon which presents problems for pure categorial grammars and
    context-free grammars centers around the intuition that sentence (25) means
    the same as sentence (26):
    25. [@25] John loves Mary, and Jack, Jill
    26. John loves Mary, and Jack loves Jill


    (25) is derived from (26) by leaving out the word *loves* in the second
    conjunct. Another conjecture is that the 'missing part' of (25) gets filled
    in during the process of interpretation. Either way, leaving out a
    constituent or filling one in introduces context-dependency into the
    picture, since the piece to be left out or filled in must always be present
    somewhere else in the structure.

    A third phenomenon which illustrates that the limited generative capacity o
    context-free grammars and pure categorial grammars may lead to unituitive
    result is that of *word order*. Both kinds of grammar decree a fixed word
    order and hence seem to fail as adequate descriptive tools for languages in
    which it is not word order.
*** Categorial Grammar and the Theory of Types
    27. [@27]
        \begin{tikzpicture}
        \tikzset{grow' = up}
        \tikzset{frontier/.style={distance from root=40pt}}
        \tikzset{level distance=25pt}
        \tikzset{every tree node/.style={align=center,anchor=north}}
        \tikzset{edge from parent/.style=
        {draw,
        edge from parent path={(\tikzparentnode.north)
        -- +(0,6pt)
        -| (\tikzchildnode)}}}
        \Tree [.$s$ {John\\$n$}
        {swims\\$n\textbackslash s$} ]
        \begin{scope}[yshift=-2.3cm]
        \Tree [.$s$ {Swimming\\$n\textbackslash s$}
        {is healthy\\$(n\textbackslash s)\textbackslash s$} ]
        \end{scope}
        \begin{scope}
        \node [xshift=3.5cm,yshift=1cm] {$(S_{\la e,t\ra}(j_e))$};
        \node  [xshift= 3.5cm,yshift=-1.3cm] {$H_{\la\la e,t\ra,t\ra}(S_{\la e,t\ra})$};
        \node [yshift=-3.5cm] {\textit{Categorial grammar}};
        \node [yshift=-3.5cm,xshift=3.5cm] {\textit{Theory of types}};
        \end{scope}
        \end{tikzpicture}
** \(λ\)-Abstraction
*** The \(λ\)-Operator
    29. [@29] Jogging is healthy


    A translation of this sentence into the theory of types may be obtained as
    follows. Given that *jogging* expresses a property of individuals, the
    expression may be translated as a predicate constant \(J\) of type \(\la
    e,t\ra\). *Healthy* expresses, a property of properties of individuals and is
    as such to be rendered as a constant \(\calh\) of type \(\la\la e,t\ra,t\).
    The whole of (29) is then to be translated as the formula \(\calh(J)\)

    30. [@30] Not smoking is healthy
    31. Drinking and driving is unwise
    32. John admires John
    33. John admires himself


    In order to account for constructions like these, the following rule is
    added to the syntax of the theory of types as given in definition 2 in
    ref:def4.2.2
    7. [@7] If \alpha is expression of type \(a\) in \(L\), and \(v\) is a variable
       of type \(b\), then \(\lambda v\alpha\) is expression of type \(\la b,a\ra\) in
       \(L\)


    Let \(W\) be a constant of type \(\la e,t\ra\), and let \(x\) be a variable
    of type \(e\). Then \(W(x)\) is a formula in which \(x\) appears as a free
    variable. We can form the expression \(\lambda x(W(x))\) of type \(\la e,t\ra\).
    We say that the expression \(\lambda x(W(x))\) has been formed from the expression
    \(W(x)\) by *abstraction over* the free variable \(x\). We say that the free
    occurrences of the variable \(x\) in \alpha are *bound* in \(\lambda x\alpha\) by the
    *\(\lambda\)-operator* \(\lambda x\)

    The interpretation of a \(\lambda\)-abstraction \(\lambda x_b\alpha_a\) is a
    function. For this reason, \(\lambda\)-abstraction is also referred to as
    *functional abstraction*.

    Now we add the following clause to Definition 
    6. [@6] If \(\alpha\in\WE^L_a\) and \(v\in\VAR_b\), then \(\llbracket \lambda
       v\alpha\rrbracket_{\bM,g}\) is that function \(h\in\bD_a^{\bD_b}\) s.t.
       for all \(d\in\bD_b\):\(h(d)=\llbracket\alpha\rrbracket_{\bM,g[v/d]}\)


    Sentence (30), /Not smoking is healthy/, can be translated as follows. Let
    \(S\) be the translation of /smoking/. This is a constant of type \(\la
    e,t\ra\). And let \(x\) be a variable of type \(x\). We obtain the
    expression \(\lambda x\neg S(x)\) of type \(\la e,t\ra\). The whole of (30) may
    now be obtained by applying the second-order predicate \(\calh\). The result
    is \(\calh(\lambda x\neg S(x))\)
*** \(λ\)-Conversion
    The general notation for the result of replacing all free occurrences of a
    variable \(v\) in an expression \beta by an expression \gamma is \([\gamma/v]\beta\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A variable \(v'\) is *free for \(v\)*  in the expression \beta iff no free
    occurrence of \(v\) in \beta is within the scope of a quantifier \(\exists v'\)
    or \(\forall v'\) or a \(\lambda\)-operator \(\lambda v'\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    If all variables which occurs as free variables in \gamma are free for \(v\) in
    \beta, then \(\lambda v\beta(\gamma)\) and \([\gamma/v]\beta\) are equivalent
    #+END_theorem
*** The \(λ\)-Operator and Compositionality
    The main purpose of translating a natural language into a formal language is
    to obtain a semantic interpretation of the former via the semantics of the
    latter. For the meaning of a correct translation is the same as the meaning
    of what is translated. In order for the semantic interpretation to be
    satisfactory, it is necessary that the process of translation comply to
    certain requirements. Among these, two important requirements are that the
    process be *explicit* and that it can be *specified in a finite manner*.  The
    requirement that is be explicit means that it may not in any way rely on the
    knowledge or creativity of the translator: it must be such that it could, at
    least in principle, be automated. Furthermore, the translation process,
    though essentially finite,must translate a potentially infinite number of
    sentences.

    One way of doing this is to stay closed to the syntactic rules of the
    natural language in question, which are finite in number. Here we assume
    that translations are available for all of the lexical elements of the
    language, which are finite in number. The for each syntactic rule saying how
    expressions may be combined to form composite expressions we formulate a
    parallel rule, which says how the translations of these expressions may be
    combined to give the translations of the composite expressions.

    Now it should be clear that the way we have translated natural language
    sentences into standard predicate logic up until now is neither explicit nor
    compositional.
    35. [@35] John smokes and drinks
    36. \(Sj\wedge Dj\)


    The way of translating is not explicit, in that essential use is made of our
    knowledge of the meaning of (35), in particular our knowledge of the fact
    that (35) expressions a conjunction of two sentences. And it is not
    compositional, in that no account is given of how the translation of (35) is
    built up from the translations of *John* and *smokes and drinks*, or how the
    translation of the *smokes and drinks* is built up from the translations of
    *smokes* and *drinks*. Given that the lexical elements of (35) are rendered as
    follows: \(John:j,smokes:S,drinks:D\), the phrase *smokes and drinks* can be
    rendered as (37), while the whole of (35) translates as (38)
    37. [@37] \(\lambda x(S(x)\wedge D(x))\)
    38. \(\lambda x(S(x)\wedge D(x))(j)\)


    We shall introduce the first-order quantifiers \(\exists\) and \(\forall\)
    categorematically by treating them as second-order predicates, that is to
    say, as expressions of type \(\la\la e,t\ra,t\ra\)
    #+BEGIN_center
    \(I(\exists)\) is that function \(f_{\exists}\in\{0,1\}^{(\{0,1\}^D)}\) s.t.
    if \(h\in\{0,1\}^D\),then \par
    \(f_\exists(h)=1\) iff there is a \(d\in D\) s.t. \(h(d)=1\) \par
    \(I(\forall)\) is that function \(f_{\forall}\in\{0,1\}^{(\{0,1\}^D)}\) s.t.
    if \(h\in\{0,1\}^D\),then \par
    \(f_\exists(h)=1\) iff for all \(d\in D\) : \(h(d)=1\) 
    #+END_center
    In other words, \(I(\exists)\) is (the characteristic function of) the set
    of non-empty subsets of, that is \(\{A\mid A\subseteq D\&A\neq\emptyset\}\).
    And \(I(\forall)\) is (the characteristic function of) \(\{D\}\)

    We have interpreted \(\exists\) as the set of all nonempty subsets of \(D\).
    This means that the quantifier \(\exists\) is equivalent to the expression
    \(\lambda Y\exists x(Y(x))\) in the theory of types.
* The Intensional Theory of Types
** Intensional Constructions and Intensional Concepts
   Opaque contexts are also known as *intensional contexts*, and the expressions
   and constructions they give rise to are likewise said to be intensional 

   The intensionality of natural language is relevant at several different
   points. To begin with, natural languages contain temporal, modal, and deontic
   expressions, all of which involve intensionality. Besides these, it would
   also need expressions which refer directly to intensional entities like
   propositions, individual concepts and properties.
   1. John asserts that the Dutch queen resides in the Hague


   Now the expression *assert* in (1) cannot stand for a relation between an
   individual, in this case John, and a *sentence*, in this case
   2. [@2] The Dutch queen resides in the Hague


   For (1) may well be true without John bearing any special relation to this or
   any other English sentence. This suggests that *assert* is a relation, not
   between individuals and sentences, but between individuals and *propositions*

   If a logical theory is to provide representations of sentences which refer to
   intensional entities like propositions, then it will need expressions which
   stand for such entities.
** Syntax
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   \(\bT\), the set of types in intensional type theory, is the smallest set
   s.t.
   1. \(e,t\in\bT\)
   2. If \(a,b\in\bT\), then \(\la a,b\ra\in\bT\)
   3. If \(a\in\bT\), then \(\la s,a\ra\in\bT\)
   #+END_definition

   The vocabulary of any particular intensional, type-theoretical language \(L\)
   consists once again of a part shared by all such languages, together with a
   number of symbols which are peculiar to it. The shared part is
   1. for every type \(a\), an infinite set \(\VAR_a\) of variables of type \(a\)
   2. the connectives \(\wedge,\vee,\to,\neg,\leftrightarrow\)
   3. the quantifiers \(\forall\) and \(\exists\)
   4. the identity symbol =
   5. the operators \(\Box,\Diamond,{}^\wedge,{}^\vee\)
   6. the brackets ( and )


   The part which is peculiar to L consists of
   7. [@7] for every type \(a\), a (possibly empty) set \(\CON_a^L\) of
      constants of type \(a\)


   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. If \(\alpha\in\VAR_a\) or \(\alpha\in\CON_a^L\), then \(\alpha\in\WE_a^L\)
   2. If \(\alpha\in\WE_{\la a,b\ra}^L\) and \(\beta\in\WE_a^L\), then \((\alpha(\beta))\in\WE_b^L\)
   3. If \(\phi,\psi\in\WE_t^L\), then
      \(\neg\phi,(\phi\wedge\psi),(\phi\vee\psi)\),\(\phi\to\psi\) and
      \(\phi\leftrightarrow\psi\in\WE_t^l\)
   4. If \(\phi\in\WE_t^L\) and \(v\in\VAR_a\), then \(\forall v\phi,\exists v\phi\in\WE_t^L\)
   5. If \(\alpha,\beta\in\WE_a^L\), then \((\alpha=\beta)\in\WE_t^L\)
   6. If \(\alpha\in\WE_a^L\) and \(v\in\VAR_b\), then \(\lambda v\alpha\in\VAR_{\la b,a\ra}\)
   7. If \(\phi\in\WE_t^L\), then \(\Box\phi,\Diamond\phi\in\WE_t^L\)
   8. If \(\alpha\in\WE_a^L\), then \({}^\wedge\alpha\in\WE_{\la s,a\ra}^L\)
   9. If \(\alpha\in\WE_{\la s,a\ra}^L\), then \({}^\vee\alpha\in\WE_a^L\)
   10. Every element of \(\WE_a^L\) for any \(a\) is constructed in a finite
       number of steps using (1) - (9)
   #+END_definition

   If \(\phi\in\WE_t^L\), then \( {}^\wedge\phi\in\WE_{\la s,t\ra}^L\) refers to
   the intension of \phi, a function from possible worlds into truth values.
** Semantics
   An expression of any intensional type \(\la s,a\ra\) is to be interpreted as
   a function mapping possible worlds to elements of the interpretation domain
   corresponding to type \(a\).

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. \(\bD_{e,D,W}=D\)
   2. \(\bD_{t,D,W}=\{0,1\}\)
   3. \(\bD_{\la a,b\ra,D,W}=\bD_{b,D,W}^{\bD_{a,D,W}}\)
   4. \(\bD_{\la s,a\ra,D,W}=\bD_{a,D,W}^W\)
   #+END_definition

   An expression of type \(\la s,t\ra\) thus refers to a function from possible
   worlds to truth values. Functions of this kind will be called *propositions*.
   An expression of type \(\la s,\la e,t\ra\ra\) refers to a function from
   possible worlds to sets of individuals. Now sets of individuals serve as the
   interpretations of predicates, and a predicate refers in different worlds to
   different sets. This multiple reference of a predicate may be seen as a
   function from possible worlds to sets of individuals, and this function may
   be thought of as the predicate's intension. Any such intension will be called
   a *property*

   If \alpha is a constant of  type \(a\), then \(I(\alpha)\in\bD_a^W\). We refer to
   \(\llbracket\alpha\rrbracket_{\bM,w,g}\) as the
   *extension of \alpha in \(w\), given \(\bM\) and \(g\)*

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   1. If \(\alpha\in\CON_a^L\), then
      \(\llbracket\alpha\rrbracket_{\bM,w,g}=I(\alpha)(w)\)

      If \(\alpha\in\VAR_a\), then \(\llbracket\alpha\rrbracket_{\bM,w,g}=g(\alpha)\)

   2. If \(\alpha\in\WE_{\la a,b\ra}^L\) and \(\beta\in\WE_a^L\), then
      \(\llbracket\alpha(\beta)\rrbracket_{\bM,w,g}=\llbracket\alpha
       \rrbracket_{\bM,w,g}(\llbracket\beta\rrbracket_{\bM,w,g})\)

   3. If \(\phi,\psi\in\WE_t^L\), then \(\llbracket\neg\phi\rrbracket_{\bM,w,g}=1\)
      iff \(\llbracket\phi\rrbracket_{\bM,w,g}=0\)

       \(\llbracket\phi\wedge\psi\rrbracket_{\bM,w,g}=1\) iff
       \(\llbracket\phi\rrbracket_{\bM,w,g}=\llbracket\psi\rrbracket_{\bM,w,g}=1\)

       \(\llbracket\phi\to\psi\rrbracket_{\bM,w,g}=0\) iff
       \(\llbracket\phi\rrbracket_{\bM,w,g}=1\) and
       \(\llbracket\psi\rrbracket_{\bM,w,g}=0\)

       \(\llbracket\phi\leftrightarrow\psi\rrbracket_{\bM,w,g}\) iff
       \(\llbracket\phi\rrbracket_{\bM,w,g}=\llbracket\psi\rrbracket_{\bM,w,g}\)

   4. if \(\phi\in \WE_t^L,v\in \VAR_a\), then

       \(\llbracket\forall v\phi\rrbracket_{\bM,w,g}=1\) iff for all
       \(d\in\bD_{a,D}\):
       \(\llbracket\phi\rrbracket_{\bM,w,g[v/d]}=1\)

       \(\llbracket\exists v\phi\rrbracket_{\bM,w,g}=1\) iff there is at least one
       \(d\in\bD_{a,D}\) s.t.: \(\llbracket\phi\rrbracket_{\bM,w,g[v/d]}=1\)

   5. If \(\alpha,\beta\in \WE_a^L\), then
       \(\llbracket\alpha=\beta\rrbracket_{\bM,w,g}=1\) iff
       \(\llbracket\alpha\rrbracket_{\bM,w,g}=\llbracket\beta\rrbracket_{\bM,w,g}\)

   6. If \(\alpha\in\WE_a^L\) and \(v\in\VAR_b\), then \(\llbracket\lambda
      v\alpha\rrbracket_{\bM,w,g}\) is that function \(f\in\bD_a^{\bD_b}\) s.t.
      for all \(d\in \bD_b\):\(h(d)=\llbracket\alpha\rrbracket_{\bM,w,g[v/d]}\)

   7. If \(\phi\in\WE_t^L\), then

      \(\llbracket\Box\phi\rrbracket_{\bM,w,g}=1\) iff for all \(w'\in W\):
      \(\llbracket\phi\rrbracket_{\bM,w',g}=1\)

      \(\llbracket\Diamond\phi\rrbracket_{\bM,w,g}=1\) iff for some \(w'\in W\):
      \(\llbracket\phi\rrbracket_{\bM,w',g}=1\)

   8. If \(\alpha\in\WE_a^L\), then
      \(\llbracket{}^\wedge\alpha\rrbracket_{\bM,w,g}\) is that function
      \(h\in\bD^w_a\) s.t. for all \(w'\in W\): \(h(w')=\llbracket\alpha\rrbracket_{\bM,w',g}\)

   9. If \(\alpha\in\WE^L_{\la s,a\ra}\), then
      \(\llbracket{}^\vee\alpha\rrbracket_{\bM,w,g}=
      \llbracket\alpha\rrbracket_{\bM,w,g}(w)\)

     
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   If \(\alpha\in\WE_a^L\), then \(\Int_{\bM,g}(\alpha)\) is that \(h\in\bD^W_a\)
   s.t. for all \(w'\in W\):\(h(w')=\llbracket\alpha\rrbracket_{\bM,w',g}\)
   #+END_definition

   Hence \(\Int_{\bM,g}(\alpha)(w)=\llbracket\alpha\rrbracket_{\bM,w,g}=I(\alpha)(w)\).
   This means \(\Int_{\bM,g}(\alpha)=I(\alpha)\). Also, the extension of
   \({}^\wedge\alpha\) is just the intension of \alpha. What this means is that given
   any expression \alpha, the \({}^\wedge\)-operator enables us to form an expression
   \({}^\wedge\alpha\) whose extension is \(\alpha\)'s intension

   In an intensional system we do not have
   \begin{equation*}
   \alpha=\beta\models\gamma=[\beta/\alpha]\gamma
   \end{equation*}

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   \({}^\wedge\alpha={}^\wedge\beta\models\gamma=[\beta/\alpha]\gamma\)
   #+END_theorem

** The Operators \({}^\wedge\) and \({}^\vee\)

   \({}^\wedge\alpha\) denotes the intension of \alpha. That is, for any \(\bM,w,g\)
   we have
   5. [@5] \(\llbracket^\wedge\alpha\rrbracket_{\bM,w,g}=\Int_{\bM,g}(\alpha)\)


   The denotation of \({}^\vee\alpha\) in any world \(w\) is the extension of \alpha
   in \(w\) applied to \(w\):
   \(\llbracket^\vee\alpha\rrbracket_{\bM,w,g}=\llbracket\alpha\rrbracket_{\bM,w,g}(w)\)

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   \({}^{\vee\wedge}\alpha\) is equivalent to \alpha
   #+END_theorem

   #+BEGIN_proof
   \begin{equation*}
   \llbracket^{\vee\wedge}\alpha\rrbracket_{\bM,w,g}=
   \llbracket^\wedge\alpha\rrbracket_{\bM,w,g}(w)=
   \Int_{\bM,g}(\alpha)(w)=\llbracket\alpha\rrbracket_{\bM,w,g}
   \end{equation*}
   #+END_proof

   Let \(\bM\) be a model with two worlds, \(w_1\) and \(w_2\). Consider the
   constant \(p\) of type \(\la s,t\ra\). The extension of \(p\) is thus a
   proposition. We may assume the extension of \(p\) in \(w_1\) to be that
   proposition \(k\) which has the truth value 1 when applied to \(w_1\) and the
   truth value 0 when applied to \(w_2\). We may furthermore stipulate that the
   extension of \(p\) in \(w_2\) is that proposition \(k'\) which has the truth
   value 0 when applied to \(w_1\) and the truth value 1 when applied to
   \(w_2\). That is to say
   \begin{alignat*}{25pt}
   &I(p)(w_1)=k\quad&&k(w_1)=1\\
   &k(w_2)=0&&\\
   &I(p)(w_2)=k'&&k'(w_1)=0\\
   &k'(w_2)=1&&
   \end{alignat*}
   Now we have \(\llbracket^{\vee\wedge}p\rrbracket_{\bM,w_1,g}\neq\llbracket
   p\rrbracket_{\bM,w_1,g}\). Now
   #+BEGIN_center
   \(\llbracket^{\wedge\vee}p\rrbracket_{w_1}=\) that function \(h\in\{0,1\}^w\)
   s.t. for all \(w'\in W:h(w')=\llbracket^{\vee}p\rrbracket_{w'}\)

   \(h(w_1)=\llbracket^\vee p\rrbracket_{w_1}=\llbracket
   p\rrbracket_{w_1}(w_1)=I(p)(w_1)(w_2)=k(w_1)=1\)

   \(h(w_2)=\llbracket^\vee p\rrbracket_{w_2}=\llbracket
   p\rrbracket_{w_2}(w_2)=I(p)(w_2)(w_2)=k'(w_2)=1\)
   #+END_center

   Hence \(h\) is always true. But \(\llbracket p\rrbracket_{w_1}\) is not


   Assume  the sentence *Mary is coming* to be true in \(w_1\) and false in
   \(w_2\). The proposition \(k\) may then be seen as the proposition expressed
   by this sentence; The proposition \(k'\) is expressed by the sentence *Mary*
   *is not coming*. According to our stipulation above, the extension of the
   constant \(p\) in \(w_1\), the world in which she is coming, is the
   proposition that Mary is coming, while the extension of this constant in
   \(w_2\), the world in which she is not coming, is the proposition that Mary
   is not coming. The makes \(p\) a suitable representation of the expression
   *whether or not Mary is coming* as it appears in 6
   6. [@6] John knows whether or not Mary is coming


   For consider the following two valid arguments
   7. [@7]
      | John knows whether or not Mary is coming |
      | Mary is coming                           |
      |------------------------------------------|
      | John knows that Mary is coming           |
   8.
      | John knows whether or not Mary is coming |
      | Mary is not coming                       |
      |------------------------------------------|
      | John knows that Mary is not coming       |


   The validity of (7) and (8) shows that given that Mary is coming, the
   extension of *whether or not Mary is coming* is the proposition that Mary is
   coming

   If \alpha is an expression which have same extension in different worlds, then
   \(^{\wedge\vee}\alpha\) and \alpha turn out to be equivalent. More generally, we
   may define a class of expressions whose extension does not vary from world to
   world, the class of *intensionally closed expresions*:
   
   #+ATTR_LATEX: :options []
   #+BEGIN_definition
   \(\ICE^L\), the class of intensionally closed expressions in \(L\), is the
   minimal subset of \(\WE^L\) s.t.
   1. If \(v\in\VAR_a\), then \(v\in\ICE^L\)
   2. If \(\alpha\in\WE_a^L\), then \({}^\wedge\alpha\in\ICE^L\)
   3. If \(\phi\in\WE_t^L\), then \(\Box\phi,\Diamond\phi\in\ICE^L\)
   4. If \alpha is constructed from elements from \(\ICE^L\) using only connectives,
      quantifiers, and the \(\lambda\)-operator, then \(\alpha\in\ICE^L\)
   #+END_definition

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   If \(\alpha\in\ICE^L\), then
   \(\llbracket\alpha\rrbracket_{\bM,w,g}=\llbracket\alpha\rrbracket_{\bM,w',g}\)
   for all \(\bM,w,w'\)
   #+END_theorem

   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   If \(\alpha\in\ICE^L\), then \({}^{\wedge\vee}\alpha\) is equivalent to \alpha
   #+END_theorem

** \(\lambda\)-Conversion
   #+ATTR_LATEX: :options []
   #+BEGIN_theorem
   \(\lambda v\beta(\gamma)\) is equivalent to \([\lambda/v]\beta\) if
   1. all free variables in \gamma are free for \(v\) in \beta
   2. either \(\gamma\in\ICE^L\), or no free occurrence of \(v\) in \beta, lies
      within the scope of \(\Box,\Diamond,{}^\wedge\)
   #+END_theorem
